#!/usr/bin/env python

#
# Generated  by generateDS.py.
#

import sys
import getopt
from string import lower as str_lower
from xml.dom import minidom
from xml.dom import Node

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def format_string(self, input_data, input_name=''):
            return input_data
        def format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def format_boolean(self, input_data, input_name=''):
            return '%s' % input_data


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class jobsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('job', 'jobType', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, job=None):
        if job is None:
            self.job = []
        else:
            self.job = job
    def factory(*args_, **kwargs_):
        if jobsType.subclass:
            return jobsType.subclass(*args_, **kwargs_)
        else:
            return jobsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_job(self): return self.job
    def set_job(self, job): self.job = job
    def add_job(self, value): self.job.append(value)
    def insert_job(self, index, value): self.job[index] = value
    def export(self, outfile, level, namespace_='cny:', name_='jobsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='jobsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='cny:', name_='jobsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cny:', name_='jobsType'):
        for job_ in self.job:
            job_.export(outfile, level, namespace_, name_='job')
    def hasContent_(self):
        if (
            self.job
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='jobsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('job=[\n')
        level += 1
        for job_ in self.job:
            showIndent(outfile, level)
            outfile.write('model_.jobType(\n')
            job_.exportLiteral(outfile, level, name_='jobType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'job':
            obj_ = jobType.factory()
            obj_.build(child_)
            self.job.append(obj_)
# end class jobsType


class jobType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('href', 'xsd:anyURI', 0),
        MemberSpec_('id', 'xsd:string', 0),
        MemberSpec_('type_', 'xsd:token', 0),
        MemberSpec_('status', ['status', 'xsd:token'], 0),
        MemberSpec_('created', ['timestampType', 'xsd:decimal'], 0),
        MemberSpec_('modified', ['timestampType', 'xsd:decimal'], 0),
        MemberSpec_('createdBy', 'xsd:token', 0),
        MemberSpec_('expiration', ['timestampType', 'xsd:decimal'], 0),
        MemberSpec_('cloudName', 'xsd:token', 0),
        MemberSpec_('cloudType', 'xsd:token', 0),
        MemberSpec_('instanceId', 'xsd:anyURI', 0),
        MemberSpec_('imageId', 'xsd:anyURI', 0),
        MemberSpec_('history', 'historyEntryType', 1),
        MemberSpec_('errorResponse', 'errorType', 0),
        MemberSpec_('result', 'xsd:string', 1),
        MemberSpec_('resultResource', 'resultResourceType', 1),
        ]
    subclass = None
    superclass = None
    def __init__(self, href=None, id=None, type_=None, status=None, created=None, modified=None, createdBy=None, expiration=None, cloudName=None, cloudType=None, instanceId=None, imageId=None, history=None, errorResponse=None, result=None, resultResource=None):
        self.href = _cast(None, href)
        self.id = _cast(None, id)
        self.type_ = type_
        self.status = status
        self.created = created
        self.modified = modified
        self.createdBy = createdBy
        self.expiration = expiration
        self.cloudName = cloudName
        self.cloudType = cloudType
        self.instanceId = instanceId
        self.imageId = imageId
        if history is None:
            self.history = []
        else:
            self.history = history
        self.errorResponse = errorResponse
        if result is None:
            self.result = []
        else:
            self.result = result
        if resultResource is None:
            self.resultResource = []
        else:
            self.resultResource = resultResource
    def factory(*args_, **kwargs_):
        if jobType.subclass:
            return jobType.subclass(*args_, **kwargs_)
        else:
            return jobType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def validate_status(self, value):
        # Validate type status, a restriction on xsd:token.
        pass
    def get_created(self): return self.created
    def set_created(self, created): self.created = created
    def validate_created(self, value):
        # validate type created
        pass
    def get_modified(self): return self.modified
    def set_modified(self, modified): self.modified = modified
    def validate_modified(self, value):
        # validate type modified
        pass
    def get_createdBy(self): return self.createdBy
    def set_createdBy(self, createdBy): self.createdBy = createdBy
    def get_expiration(self): return self.expiration
    def set_expiration(self, expiration): self.expiration = expiration
    def validate_expiration(self, value):
        # validate type expiration
        pass
    def get_cloudName(self): return self.cloudName
    def set_cloudName(self, cloudName): self.cloudName = cloudName
    def get_cloudType(self): return self.cloudType
    def set_cloudType(self, cloudType): self.cloudType = cloudType
    def get_instanceId(self): return self.instanceId
    def set_instanceId(self, instanceId): self.instanceId = instanceId
    def get_imageId(self): return self.imageId
    def set_imageId(self, imageId): self.imageId = imageId
    def get_history(self): return self.history
    def set_history(self, history): self.history = history
    def add_history(self, value): self.history.append(value)
    def insert_history(self, index, value): self.history[index] = value
    def get_errorResponse(self): return self.errorResponse
    def set_errorResponse(self, errorResponse): self.errorResponse = errorResponse
    def get_result(self): return self.result
    def set_result(self, result): self.result = result
    def add_result(self, value): self.result.append(value)
    def insert_result(self, index, value): self.result[index] = value
    def get_resultResource(self): return self.resultResource
    def set_resultResource(self, resultResource): self.resultResource = resultResource
    def add_resultResource(self, value): self.resultResource.append(value)
    def insert_resultResource(self, index, value): self.resultResource[index] = value
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='cny:', name_='jobType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='jobType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='cny:', name_='jobType'):
        if self.href is not None:
            outfile.write(' href=%s' % (self.format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.id is not None:
            outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='cny:', name_='jobType'):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('<%stype>%s</%stype>\n' % (namespace_, self.format_string(quote_xml(self.type_).encode(ExternalEncoding), input_name='type'), namespace_))
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('<%sstatus>%s</%sstatus>\n' % (namespace_, self.format_string(quote_xml(self.status).encode(ExternalEncoding), input_name='status'), namespace_))
        if self.created is not None:
            showIndent(outfile, level)
            outfile.write('<%screated>%s</%screated>\n' % (namespace_, self.format_string(quote_xml(self.created).encode(ExternalEncoding), input_name='created'), namespace_))
        if self.modified is not None:
            showIndent(outfile, level)
            outfile.write('<%smodified>%s</%smodified>\n' % (namespace_, self.format_string(quote_xml(self.modified).encode(ExternalEncoding), input_name='modified'), namespace_))
        if self.createdBy is not None:
            showIndent(outfile, level)
            outfile.write('<%screatedBy>%s</%screatedBy>\n' % (namespace_, self.format_string(quote_xml(self.createdBy).encode(ExternalEncoding), input_name='createdBy'), namespace_))
        if self.expiration is not None:
            showIndent(outfile, level)
            outfile.write('<%sexpiration>%s</%sexpiration>\n' % (namespace_, self.format_string(quote_xml(self.expiration).encode(ExternalEncoding), input_name='expiration'), namespace_))
        if self.cloudName is not None:
            showIndent(outfile, level)
            outfile.write('<%scloudName>%s</%scloudName>\n' % (namespace_, self.format_string(quote_xml(self.cloudName).encode(ExternalEncoding), input_name='cloudName'), namespace_))
        if self.cloudType is not None:
            showIndent(outfile, level)
            outfile.write('<%scloudType>%s</%scloudType>\n' % (namespace_, self.format_string(quote_xml(self.cloudType).encode(ExternalEncoding), input_name='cloudType'), namespace_))
        if self.instanceId is not None:
            showIndent(outfile, level)
            outfile.write('<%sinstanceId>%s</%sinstanceId>\n' % (namespace_, self.format_string(quote_xml(self.instanceId).encode(ExternalEncoding), input_name='instanceId'), namespace_))
        if self.imageId is not None:
            showIndent(outfile, level)
            outfile.write('<%simageId>%s</%simageId>\n' % (namespace_, self.format_string(quote_xml(self.imageId).encode(ExternalEncoding), input_name='imageId'), namespace_))
        for history_ in self.history:
            history_.export(outfile, level, namespace_, name_='history')
        if self.errorResponse:
            self.errorResponse.export(outfile, level, namespace_, name_='errorResponse')
        for result_ in self.result:
            showIndent(outfile, level)
            outfile.write('<%sresult>%s</%sresult>\n' % (namespace_, self.format_string(quote_xml(result_).encode(ExternalEncoding), input_name='result'), namespace_))
        for resultResource_ in self.resultResource:
            resultResource_.export(outfile, level, namespace_, name_='resultResource')
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.status is not None or
            self.created is not None or
            self.modified is not None or
            self.createdBy is not None or
            self.expiration is not None or
            self.cloudName is not None or
            self.cloudType is not None or
            self.instanceId is not None or
            self.imageId is not None or
            self.history or
            self.errorResponse is not None or
            self.result or
            self.resultResource
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='jobType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.href is not None:
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % quote_python(self.type_).encode(ExternalEncoding))
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('status=%s,\n' % quote_python(self.status).encode(ExternalEncoding))
        if self.created is not None:
            showIndent(outfile, level)
            outfile.write('created=%s,\n' % quote_python(self.created).encode(ExternalEncoding))
        if self.modified is not None:
            showIndent(outfile, level)
            outfile.write('modified=%s,\n' % quote_python(self.modified).encode(ExternalEncoding))
        if self.createdBy is not None:
            showIndent(outfile, level)
            outfile.write('createdBy=%s,\n' % quote_python(self.createdBy).encode(ExternalEncoding))
        if self.expiration is not None:
            showIndent(outfile, level)
            outfile.write('expiration=%s,\n' % quote_python(self.expiration).encode(ExternalEncoding))
        if self.cloudName is not None:
            showIndent(outfile, level)
            outfile.write('cloudName=%s,\n' % quote_python(self.cloudName).encode(ExternalEncoding))
        if self.cloudType is not None:
            showIndent(outfile, level)
            outfile.write('cloudType=%s,\n' % quote_python(self.cloudType).encode(ExternalEncoding))
        if self.instanceId is not None:
            showIndent(outfile, level)
            outfile.write('instanceId=%s,\n' % quote_python(self.instanceId).encode(ExternalEncoding))
        if self.imageId is not None:
            showIndent(outfile, level)
            outfile.write('imageId=%s,\n' % quote_python(self.imageId).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('history=[\n')
        level += 1
        for history_ in self.history:
            showIndent(outfile, level)
            outfile.write('model_.historyEntryType(\n')
            history_.exportLiteral(outfile, level, name_='historyEntryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.errorResponse is not None:
            showIndent(outfile, level)
            outfile.write('errorResponse=model_.errorType(\n')
            self.errorResponse.exportLiteral(outfile, level, name_='errorResponse')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('result=[\n')
        level += 1
        for result_ in self.result:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(result_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('resultResource=[\n')
        level += 1
        for resultResource_ in self.resultResource:
            showIndent(outfile, level)
            outfile.write('model_.resultResourceType(\n')
            resultResource_.exportLiteral(outfile, level, name_='resultResourceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('href'):
            self.href = attrs.get('href').value
        if attrs.get('id'):
            self.id = attrs.get('id').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'type':
            type_ = ''
            for text__content_ in child_.childNodes:
                type_ += text__content_.nodeValue
            type_ = ' '.join(type_.split())
            self.type_ = type_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'status':
            status_ = ''
            for text__content_ in child_.childNodes:
                status_ += text__content_.nodeValue
            self.status = status_
            self.validate_status(self.status)    # validate type status
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'created':
            created_ = ''
            for text__content_ in child_.childNodes:
                created_ += text__content_.nodeValue
            self.created = created_
            self.validate_created(self.created)    # validate type created
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'modified':
            modified_ = ''
            for text__content_ in child_.childNodes:
                modified_ += text__content_.nodeValue
            self.modified = modified_
            self.validate_modified(self.modified)    # validate type modified
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'createdBy':
            createdBy_ = ''
            for text__content_ in child_.childNodes:
                createdBy_ += text__content_.nodeValue
            createdBy_ = ' '.join(createdBy_.split())
            self.createdBy = createdBy_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'expiration':
            expiration_ = ''
            for text__content_ in child_.childNodes:
                expiration_ += text__content_.nodeValue
            self.expiration = expiration_
            self.validate_expiration(self.expiration)    # validate type expiration
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'cloudName':
            cloudName_ = ''
            for text__content_ in child_.childNodes:
                cloudName_ += text__content_.nodeValue
            cloudName_ = ' '.join(cloudName_.split())
            self.cloudName = cloudName_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'cloudType':
            cloudType_ = ''
            for text__content_ in child_.childNodes:
                cloudType_ += text__content_.nodeValue
            cloudType_ = ' '.join(cloudType_.split())
            self.cloudType = cloudType_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'instanceId':
            instanceId_ = ''
            for text__content_ in child_.childNodes:
                instanceId_ += text__content_.nodeValue
            self.instanceId = instanceId_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'imageId':
            imageId_ = ''
            for text__content_ in child_.childNodes:
                imageId_ += text__content_.nodeValue
            self.imageId = imageId_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'history':
            obj_ = historyEntryType.factory()
            obj_.build(child_)
            self.history.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'errorResponse':
            obj_ = errorType.factory()
            obj_.build(child_)
            self.set_errorResponse(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'result':
            result_ = ''
            for text__content_ in child_.childNodes:
                result_ += text__content_.nodeValue
            self.result.append(result_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'resultResource':
            obj_ = resultResourceType.factory()
            obj_.build(child_)
            self.resultResource.append(obj_)
# end class jobType


class status(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('valueOf_', ['status', 'xsd:token'], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, valueOf_=''):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if status.subclass:
            return status.subclass(*args_, **kwargs_)
        else:
            return status(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='cny:', name_='status', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='status')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='cny:', name_='status'):
        pass
    def exportChildren(self, outfile, level, namespace_='cny:', name_='status'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='status'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class status


class historyEntryType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('timestamp', ['timestampType', 'xsd:decimal'], 0),
        MemberSpec_('content', 'xsd:string', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, timestamp=None, content=None):
        self.timestamp = timestamp
        self.content = content
    def factory(*args_, **kwargs_):
        if historyEntryType.subclass:
            return historyEntryType.subclass(*args_, **kwargs_)
        else:
            return historyEntryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def validate_timestamp(self, value):
        # validate type timestamp
        pass
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def export(self, outfile, level, namespace_='cny:', name_='historyEntryType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='historyEntryType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='cny:', name_='historyEntryType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cny:', name_='historyEntryType'):
        if self.timestamp is not None:
            showIndent(outfile, level)
            outfile.write('<%stimestamp>%s</%stimestamp>\n' % (namespace_, self.format_string(quote_xml(self.timestamp).encode(ExternalEncoding), input_name='timestamp'), namespace_))
        if self.content is not None:
            showIndent(outfile, level)
            outfile.write('<%scontent>%s</%scontent>\n' % (namespace_, self.format_string(quote_xml(self.content).encode(ExternalEncoding), input_name='content'), namespace_))
    def hasContent_(self):
        if (
            self.timestamp is not None or
            self.content is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='historyEntryType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.timestamp is not None:
            showIndent(outfile, level)
            outfile.write('timestamp=%s,\n' % quote_python(self.timestamp).encode(ExternalEncoding))
        if self.content is not None:
            showIndent(outfile, level)
            outfile.write('content=%s,\n' % quote_python(self.content).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'timestamp':
            timestamp_ = ''
            for text__content_ in child_.childNodes:
                timestamp_ += text__content_.nodeValue
            self.timestamp = timestamp_
            self.validate_timestamp(self.timestamp)    # validate type timestamp
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'content':
            content_ = ''
            for text__content_ in child_.childNodes:
                content_ += text__content_.nodeValue
            self.content = content_
# end class historyEntryType


class resultResourceType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('href', 'xsd:anyURI', 0),
        MemberSpec_('valueOf_', 'xsd:string', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, href=None, valueOf_=''):
        self.href = _cast(None, href)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if resultResourceType.subclass:
            return resultResourceType.subclass(*args_, **kwargs_)
        else:
            return resultResourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='cny:', name_='resultResourceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='resultResourceType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='cny:', name_='resultResourceType'):
        if self.href is not None:
            outfile.write(' href=%s' % (self.format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
    def exportChildren(self, outfile, level, namespace_='cny:', name_='resultResourceType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='resultResourceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.href is not None:
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('href'):
            self.href = attrs.get('href').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class resultResourceType


class jobRefType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('href', 'xsd:anyURI', 0),
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, href=None, valueOf_=''):
        self.href = _cast(None, href)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if jobRefType.subclass:
            return jobRefType.subclass(*args_, **kwargs_)
        else:
            return jobRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='cny:', name_='jobRefType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='jobRefType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='cny:', name_='jobRefType'):
        outfile.write(' href=%s' % (self.format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
    def exportChildren(self, outfile, level, namespace_='cny:', name_='jobRefType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='jobRefType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.href is not None:
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('href'):
            self.href = attrs.get('href').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class jobRefType


class errorType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('fault', 'faultType', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, fault=None):
        self.fault = fault
    def factory(*args_, **kwargs_):
        if errorType.subclass:
            return errorType.subclass(*args_, **kwargs_)
        else:
            return errorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fault(self): return self.fault
    def set_fault(self, fault): self.fault = fault
    def export(self, outfile, level, namespace_='cny:', name_='errorType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='errorType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='cny:', name_='errorType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cny:', name_='errorType'):
        if self.fault:
            self.fault.export(outfile, level, namespace_, name_='fault', )
    def hasContent_(self):
        if (
            self.fault is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='errorType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.fault is not None:
            showIndent(outfile, level)
            outfile.write('fault=model_.faultType(\n')
            self.fault.exportLiteral(outfile, level, name_='fault')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'fault':
            obj_ = faultType.factory()
            obj_.build(child_)
            self.set_fault(obj_)
# end class errorType


class faultType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('code', 'xsd:integer', 0),
        MemberSpec_('message', 'xsd:string', 0),
        MemberSpec_('traceback', 'xsd:string', 0),
        MemberSpec_('productCode', 'productCodeType', 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, code=None, message=None, traceback=None, productCode=None):
        self.code = code
        self.message = message
        self.traceback = traceback
        self.productCode = productCode
    def factory(*args_, **kwargs_):
        if faultType.subclass:
            return faultType.subclass(*args_, **kwargs_)
        else:
            return faultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_message(self): return self.message
    def set_message(self, message): self.message = message
    def get_traceback(self): return self.traceback
    def set_traceback(self, traceback): self.traceback = traceback
    def get_productCode(self): return self.productCode
    def set_productCode(self, productCode): self.productCode = productCode
    def export(self, outfile, level, namespace_='cny:', name_='faultType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='faultType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='cny:', name_='faultType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cny:', name_='faultType'):
        if self.code is not None:
            showIndent(outfile, level)
            outfile.write('<%scode>%s</%scode>\n' % (namespace_, self.format_integer(self.code, input_name='code'), namespace_))
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('<%smessage>%s</%smessage>\n' % (namespace_, self.format_string(quote_xml(self.message).encode(ExternalEncoding), input_name='message'), namespace_))
        if self.traceback is not None:
            showIndent(outfile, level)
            outfile.write('<%straceback>%s</%straceback>\n' % (namespace_, self.format_string(quote_xml(self.traceback).encode(ExternalEncoding), input_name='traceback'), namespace_))
        if self.productCode:
            self.productCode.export(outfile, level, namespace_, name_='productCode')
    def hasContent_(self):
        if (
            self.code is not None or
            self.message is not None or
            self.traceback is not None or
            self.productCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='faultType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.code is not None:
            showIndent(outfile, level)
            outfile.write('code=%d,\n' % self.code)
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('message=%s,\n' % quote_python(self.message).encode(ExternalEncoding))
        if self.traceback is not None:
            showIndent(outfile, level)
            outfile.write('traceback=%s,\n' % quote_python(self.traceback).encode(ExternalEncoding))
        if self.productCode is not None:
            showIndent(outfile, level)
            outfile.write('productCode=model_.productCodeType(\n')
            self.productCode.exportLiteral(outfile, level, name_='productCode')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'code':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError, exp:
                    raise ValueError('requires integer (code): %s' % exp)
                self.code = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'message':
            message_ = ''
            for text__content_ in child_.childNodes:
                message_ += text__content_.nodeValue
            self.message = message_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'traceback':
            traceback_ = ''
            for text__content_ in child_.childNodes:
                traceback_ += text__content_.nodeValue
            self.traceback = traceback_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'productCode':
            obj_ = productCodeType.factory()
            obj_.build(child_)
            self.set_productCode(obj_)
# end class faultType


class productCodeType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('valueOf_', [], 0),
        ]
    subclass = None
    superclass = None
    def __init__(self, valueOf_=''):
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if productCodeType.subclass:
            return productCodeType.subclass(*args_, **kwargs_)
        else:
            return productCodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def getAnyAttributes_(self): return self.anyAttributes_
    def setAnyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='cny:', name_='productCodeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='productCodeType')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='cny:', name_='productCodeType'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='cny:', name_='productCodeType'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value.encode(ExternalEncoding))
        else:
            outfile.write(quote_xml('%s' % self.valueOf_.encode(ExternalEncoding)))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='productCodeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            self.anyAttributes_[name] = value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class productCodeType


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def parse(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = jobsType.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="jobs", 
##         namespacedef_='')
    return rootObj


def parseString(inString):
    doc = minidom.parseString(inString)
    rootNode = doc.documentElement
    rootObj = jobsType.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="jobs",
##         namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = jobsType.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('#from generateds_job import *\n\n')
##     sys.stdout.write('import generateds_job as model_\n\n')
##     sys.stdout.write('rootObj = model_.jobs(\n')
##     rootObj.exportLiteral(sys.stdout, 0, name_="jobs")
##     sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

